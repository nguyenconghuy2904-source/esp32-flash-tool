"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[471],{471:(t,e,i)=>{i.d(e,{ESP32S3ROM:()=>a});var s=i(3830);class a extends s.n{constructor(){super(...arguments),this.CHIP_NAME="ESP32-S3",this.IMAGE_CHIP_ID=9,this.EFUSE_BASE=0x60007000,this.MAC_EFUSE_REG=this.EFUSE_BASE+68,this.EFUSE_BLOCK1_ADDR=this.EFUSE_BASE+68,this.EFUSE_BLOCK2_ADDR=this.EFUSE_BASE+92,this.UART_CLKDIV_REG=0x60000014,this.UART_CLKDIV_MASK=1048575,this.UART_DATE_REG_ADDR=0x60000080,this.FLASH_WRITE_SIZE=1024,this.BOOTLOADER_FLASH_OFFSET=0,this.FLASH_SIZES={"1MB":0,"2MB":16,"4MB":32,"8MB":48,"16MB":64},this.SPI_REG_BASE=0x60002000,this.SPI_USR_OFFS=24,this.SPI_USR1_OFFS=28,this.SPI_USR2_OFFS=32,this.SPI_MOSI_DLEN_OFFS=36,this.SPI_MISO_DLEN_OFFS=40,this.SPI_W0_OFFS=88,this.USB_RAM_BLOCK=2048,this.UARTDEV_BUF_NO_USB=3,this.UARTDEV_BUF_NO=0x3fcef14c}async getChipDescription(t){let e=await this.getMajorChipVersion(t),i=await this.getMinorChipVersion(t),s=await this.getPkgVersion(t);return`${({0:"ESP32-S3 (QFN56)",1:"ESP32-S3-PICO-1 (LGA56)"})[s]||"unknown ESP32-S3"} (revision v${e}.${i})`}async getPkgVersion(t){return await t.readReg(this.EFUSE_BLOCK1_ADDR+12)>>21&7}async getRawMinorChipVersion(t){return((await t.readReg(this.EFUSE_BLOCK1_ADDR+20)>>23&1)<<3)+(await t.readReg(this.EFUSE_BLOCK1_ADDR+12)>>18&7)}async getMinorChipVersion(t){let e=await this.getRawMinorChipVersion(t);return await this.isEco0(t,e)?0:this.getRawMinorChipVersion(t)}async getRawMajorChipVersion(t){return await t.readReg(this.EFUSE_BLOCK1_ADDR+20)>>24&3}async getMajorChipVersion(t){let e=await this.getRawMinorChipVersion(t);return await this.isEco0(t,e)?0:this.getRawMajorChipVersion(t)}async getBlkVersionMajor(t){return(await t.readReg(this.EFUSE_BLOCK2_ADDR+16)|0)&3}async getBlkVersionMinor(t){return await t.readReg(this.EFUSE_BLOCK1_ADDR+12)>>24&7}async isEco0(t,e){return(7&e)==0&&await this.getBlkVersionMajor(t)===1&&await this.getBlkVersionMinor(t)===1}async getFlashCap(t){let e=this.EFUSE_BASE+68;return await t.readReg(e+12)>>27&7}async getFlashVendor(t){let e=this.EFUSE_BASE+68;return({1:"XMC",2:"GD",3:"FM",4:"TT",5:"BY"})[(0|await t.readReg(e+16))&7]||""}async getPsramCap(t){let e=this.EFUSE_BASE+68;return await t.readReg(e+16)>>3&3}async getPsramVendor(t){let e=this.EFUSE_BASE+68;return({1:"AP_3v3",2:"AP_1v8"})[await t.readReg(e+16)>>7&3]||""}async getChipFeatures(t){let e=["Wi-Fi","BLE"],i=await this.getFlashCap(t),s=await this.getFlashVendor(t),a={0:null,1:"Embedded Flash 8MB",2:"Embedded Flash 4MB"}[i];null!==a&&e.push(`${void 0!==a?a:"Unknown Embedded Flash"} (${s})`);let r=await this.getPsramCap(t),n=await this.getPsramVendor(t),h={0:null,1:"Embedded PSRAM 8MB",2:"Embedded PSRAM 2MB"}[r];return null!==h&&e.push(`${void 0!==h?h:"Unknown Embedded PSRAM"} (${n})`),e}async getCrystalFreq(t){return 40}_d2h(t){let e=(+t).toString(16);return 1===e.length?"0"+e:e}async postConnect(t){let e=await t.readReg(this.UARTDEV_BUF_NO)&255;t.debug("In _post_connect "+e),e==this.UARTDEV_BUF_NO_USB&&(t.ESP_RAM_BLOCK=this.USB_RAM_BLOCK)}async readMac(t){let e=await t.readReg(this.MAC_EFUSE_REG);e>>>=0;let i=await t.readReg(this.MAC_EFUSE_REG+4);i=i>>>0&65535;let s=new Uint8Array(6);return s[0]=i>>8&255,s[1]=255&i,s[2]=e>>24&255,s[3]=e>>16&255,s[4]=e>>8&255,s[5]=255&e,this._d2h(s[0])+":"+this._d2h(s[1])+":"+this._d2h(s[2])+":"+this._d2h(s[3])+":"+this._d2h(s[4])+":"+this._d2h(s[5])}getEraseSize(t,e){return e}}},3830:(t,e,i)=>{i.d(e,{n:()=>s});class s{getEraseSize(t,e){return e}}}}]);